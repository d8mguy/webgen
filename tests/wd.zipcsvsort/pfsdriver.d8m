// driver template: copied to make pfsdriver.d8m, substituting for the pattern %%n where n is 0, 1, etc.

import go "os"
import go "os/exec"
import "strings"
import go "flag"
import "file"
import "codecs/json"
import "regexp"
import "combics" melted
import "bytes"
import go "time"

// This has to be kept in sync with other versions. Todo: improve this.
val Parameter = tuple(
    ident:string,
    explanation:string,
    unit: string,
    elements:list(string)
)
val Output = tuple(
    ident:string,
    explanation:string,
    unit: string
)
val Cubedef = tuple(
    ident:string,
    description:string,
    params:list(Parameter),
    outputs:list(Output)
)
val PfsData = tuple(
    cube: Cubedef,
    substns: list(Parameter),
    contexts: list(tuple(key:string, value:list(string))),
    version: integer
)


// This should be the same length as the one in perfsisXlt.d8m
val letters = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p"]

// The body of this ftn is generated by substituting the range specs into the pushb args, so there's one line per parameter
val genParams = \mod(strgs:list(list(string))) {
    
}

val nOutputs = 5

val numRegexp = [regexp.regexpT: "^-?([0-9]*\\.[0-9]+|[0-9]+)$"]     // handles int and float, not exponentials, not hex, etc.

// Given a base filename, generate data for it. This involves several steps:
// 1. compile the .d8m version of the file to .go and then the .go version to executable
// 2. create a .csv file to hold the data
// 3. generate arg values for each combination of param values, run the executable, add output to the csv.
// Note that the value generation for parameters comes from genParams, whose code was generated from the range specs
// in a given perfspec file.
val generateData = \mod(fname:file.filenameParts, paramStrgs: list(list(string)), rpts: list(integer), dirname: string, starttime: time.Time) {
    val compile1 = exec.Command("d8mc", [file.filenamePut(fname).to_s]).CombinedOutput()
    val outstrg = cvt(compile1.out, string)
    if(compile1.err != nil) exit(cvt(compile1.err, string) + "; compile returns " + outstrg)
    val fn2 = file.filenamePut([file.filenameParts: ".", fname.base, ""]).to_s
    val fncsv = file.filenamePut([file.filenameParts: dirname, fname.base, "csv"]).to_s
    var csvf = file.createBasic(fncsv)
    val paramCounts = paramStrgs.{ this.count }
    each(seed^rpts) {
        if(paramStrgs == []) {      // no params?
            val rslt = exec.Command(fn2, ["-seed=#{seed}"]).CombinedOutput()
            val outstrg2 = cvt(rslt.out, string)
            if(rslt.err != nil) exit("exec failed on no param case, output=" + outstrg2)
            // verify that the result is a single line of comma-separated numbers
            unless(outstrg2.[this == '\n'].count == 1) exit("expected a single line of output, output=" + outstrg2)
            unless(all(bytes.split(rslt.out[0...outstrg2.count-1], [',']).{ numRegexp.findIndex(this).count == 2 })) exit("bad format")
            csvf.write(rslt.out)
        } else {
            var strm = [streamIndices: paramCounts]
            while(!strm.done) {
            val indices = strm.next
            val prmvals0 = indices.{ paramStrgs[index][this] }  // prmvals0:list(string) selects the next value for each param
            var reportingProgress = time.Since(starttime).Seconds() > 2.0
            var args:list(string) = ["-seed=#{seed}"]
            each(this^xp([ltr~letters[0...prmvals0.count], v~prmvals0])) { args.pushb("-#{ltr}"); args.pushb(v) }
            if(reportingProgress) println("running", fn2, args)
            val rslt = exec.Command(fn2, args).CombinedOutput()
            val outstrg2 = cvt(rslt.out, string)
            if(rslt.err != nil) exit("exec failed on #{args}, output=" + outstrg2)
            // verify that the result is a single line of comma-separated numbers
            unless(outstrg2.[this == '\n'].count == 1) exit("expected a single line of output, output=" + outstrg2)
            unless(all(bytes.split(rslt.out[0...outstrg2.count-1], [',']).{ numRegexp.findIndex(this).count == 2 })) exit("bad format")
            // assemble and write the next output line from the param values and the result of running the LM
            csvf.write(strings.join(prmvals0, ",")); csvf.write(","); csvf.write(rslt.out)
        }
        }
    }
    csvf.close()
}

// seeded is allowed to be count or [n0,n1,...] where ni are seed values
var seeded: string = flag.String(`r`, ``, "n for count, or [n0,n1,...] for list of seeds to run with")
var cxtarg: string = flag.String(`c`, ``, "context as filename or list(pair of colon separated fields)")
var importVersion: boolean = flag.Bool(`i`, false, "import a new version instead of running LM files with file or files in arglist (-c should be set as well)")
var setVersion: integer = flag.Int(`v`, -1, "if >= 0, write to this version instead of creating a new one")
var firstrun : boolean = flag.Bool(`f`, false, "set by driver to fill in param elements")

val getMetadata = \imp() {
    var fd = file.openBasic("./pfsData.json")
    val bytes: list(byte) = zerolist(fd.size())
    fd.read(bytes)
    fd.close()
    var jstrm = [json.jsonStreamer: bytes]
    var pfsd: PfsData = jstrm.fromJson()
    val errs = jstrm.errors()
    if(errs != "") exit(errs)
    pfsd
}

// Cxtarg is a flag global; can be a literal or the name of a file containing a literal
// We don't accept any flexibility on the literal, no embedded whitespace, just [text,...], where the text between
// commas is key:value. Return a list of string pairs
val getContextArg = \imp() -> list(list(string)) {
    if(cxtarg == "") return []
    var cxtstrg = cxtarg
    if(cxtarg[0] != '[') {
        var cxtfd = file.openWithError(cxtarg)
        if(tag(cxtfd) != :ok) exit(cxtfd)
        val bytes: list(byte) = zerolist(cxtfd.size())
        cxtfd.read(bytes)
        cxtfd.close()
        cxtstrg = cvt(bytes, string)
    }
    // treat cxtstrg as a literal: [X] where X is comma separated fields, each a pair with :
    val fields = strings.split(cxtstrg[1...cxtstrg.count-1], ",").{ strings.split(this, ":").{ strings.trimSpace(this) } }
    unless(all(fields.{this.count == 2})) exit("context arg: bad format")
    fields

}

val generateAll = \imp() {
    flag.Parse()
    var paramStrgs:list(list(string)) = []
    // enumerate the parameter elements by interpreting the range exprs in the original spec
    genParams(paramStrgs)
    var pfsd = getMetadata()
    var nVersion = pfsd.version+1
    if(setVersion > nVersion) exit("-v error: version #{setVersion} doesn't exist")
    if(setVersion >= 0) nVersion = setVersion
    else pfsd.version += 1
    val cxtwarning = importVersion ? "warning: import done but without context info" : "warning: contexts will be empty"
    if(cxtarg == "") {
        println(cxtwarning)
        each(kvpair^pfsd.contexts) kvpair.value.pushb("")
    } else {
        var cxt0 = getContextArg()
        each(kvpair^pfsd.contexts) {
            // Why take the index? Because as of 01/14/23, not doing so tickles a backend compiler bug. It's on my todo list to fix.
            val cxmatch = cxt0[this[0] == kvpair.key => index]
            kvpair.value.pushb(cxmatch == nil ? "" : cxt0[cxmatch][1])
            if(cxmatch != nil) cxt0[cxmatch].pushb("seen")       // mark this elt
        }
        // now check if there are new keys in cxt0
        each(pair^cxt0)
            if(pair.count == 2) {
                var kvp0 = [key~pair[0], value~(1...pfsd.version).{""}]
                kvp0.value.pushb(pair[1])
                pfsd.contexts.pushb(kvp0)
            }
    }
    if(importVersion) {
        // the flag puts us in "import mode": import csv files in a new version directory, updated metadata
        val cliArgs = flag.Args()
        var csvnames = cliArgs
        var dirPfx = ""
        if(cliArgs.count == 1 && !strings.endsWith(cliArgs[0], ".csv")) {     // arg must be a dir name
            dirPfx = cliArgs[0] + "/"
            val rddir = os.ReadDir(cliArgs[0])
            if(rddir.err != nil) exit("can't read " + cliArgs[0])
            csvnames = rddir.ok.{this.Name()}.[strings.endsWith(this, ".csv")]
        }
        unless(csvnames.count > 0 && all(csvnames.{strings.endsWith(this, ".csv")})) exit("imported filenames must have csv extensions")
        // now read the files, check the row and col counts. If ok, actually do the import and update the json metadata
        // Knowing the expected #rows and cols isn't trivial, we have a calc to make that we had to plan for. #cols is nParams+nOutputs;
        // perfsisBE has given us nOutputs via a template substn. We get nParams from genParams, then #rows is the product of elt counts
        val paramCounts = paramStrgs.{ this.count }
        val ncols = nOutputs + paramCounts.count
        val nrows = paramCounts.reduce($*, 1)
        each(fnm^csvnames) {
            var fd = file.openWithError(fnm)
            if(tag(fd) != :ok) { print("failing import:"); exit(fd) }
            val bytes: list(byte) = zerolist(fd.size())
            fd.read(bytes)
            fd.close()
            val rows = bytes.split(bytes, ['\n'])
            // take a shortcut: only check first row's cols
            if(rows.count != nrows || bytes.split(rows[0], ",").count != ncols) exit("file #{fnm} does not have expected row and/or col count")
            var destfd = file.createBasic(dirPfx + fnm)
            destfd.write(bytes)
        }
        // we write back pfsd after the merge
    } else {
        // here for the normal stuff: generate some csv files, check for firstrun
        val substnCounts = [1]
        var indices = [streamIndices: substnCounts]
        var repeats = [0]           // list of seeds for repeated runs; 0 means don't set a seed
        unless(seeded == "") {
            if(seeded[0] == '[') repeats = strings.split(seeded[1...seeded.count-1], ",").{ this.to_i }
            else { val nrpt = seeded.to_i; if(nrpt > 1) repeats = (1..nrpt).{0} }
        }
        var dirname = "./#{nVersion}"
        var starttime = time.Now()
        val dirstat = file.quickCheck(dirname)
        if(dirstat < 0) os.MkdirAll(dirname, 0x1cb)       // octal 755 = 1cb
        else if(dirstat == 0) exit("trying to mkdir #{dirname} but a non-directory already exists with that name")
        while(!indices.done) {
            val ind0 = indices.next
            val fnm = "LM" + ind0.{ letters[this][0] }.to_s
            var fnmpath = [file.filenameParts: ".", fnm, "d8m"]     // names the previously generated d8m file with current substn
            generateData(fnmpath, paramStrgs, repeats, dirname, starttime)
        }
        if(firstrun) {
            // generator created this program with the cube's Parameter.elements and contexts empty. Read, modify, write back.
            // copy the parameter element values into the metadata
            each(i^0...pfsd.cube.params.count) pfsd.cube.params[i].elements = paramStrgs[i]
            // next, get and interpret the context arg, setting pfsd.contexts with it. Cxtarg can be a filename or literal
        }
    }
    // now write the updated PfsData back to its file
    var jstrmOut = [json.jsonStreamer: ]
    jstrmOut.toJson(pfsd)
    var fd = file.createBasic("./pfsData.json")
    fd.write(jstrmOut.out())
    fd.close()
}


